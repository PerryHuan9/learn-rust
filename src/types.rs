/**
 * rust是静态类型语言，在编译时需要知道每一个变量的类型，所以当变量是经过计算得到，而可能有多种结果时，变量类型需要手动指定。
 * 类型有两个子集： scalar（标量）和 compound（复合）
 * 标量类型
 * 整形，浮点型，布尔型， 字符型
 * 有符号整形：i8,i16,i32,i64,i128,isize
 * 无符号整形：u8,u16,u32,u64,u128,usize
 * usize,isize取决于计算机架构，在64位计算机中为64位，32位架构则是32位
 *
 * 浮点型： f32,f64
 * 不同位数整形不能进行运算，整形也不能和浮点型进行运算，需要转为同一类型，同一位数才能进行运算，并且其结果也是同样的类型；
 *
 * 布尔型：只有两个值 true和false
 *
 * 字符类型：
 * 使用四个字节表示，使用了unicode字符集，可以表示任意字符
 *
 *
 *
 * 复合类型
 * 支持自定义复合类型，原生的有元组，数组
 *
 * 元组：支持不同类型的固定长度集合
 * 数组：相同类型固定长度集合
 *
 */

pub fn test_type() {
    let u1 = 1231;
    let u2: i128 = 123132323;
    let u3 = u1 / u2;
    let i5 = 888;
    let u5: u32 = 666;
    let u6 = i5 * u5;
    println!("u1={}\nf1={}\nu3={}", u1, u2, u3);

    let f1 = 3.14159;
    let mut f2: f32 = 3.333333;
    let f3 = u1 as f64 / f1;
    let u4 = f1 as i128 * u1;
    println!("f1={}\nf2={}\nf3={}\nu4={}", f1, f2, f3, u4);

    let b1 = true;
    let b2 = false;
    println!("b1={};b2={}", b1, b2);

    let c1 = '中';
    let c2 = 'a';
    let c3 = '😻';
    println!("c1={}\nc2={}\nc3={}", c1, c2, c3);

    let t1: (f32, u16, i32) = (f2, 23, 88);
    let t2: (bool, f64) = (true, f3);
    println!("t1.0={}\nt1.1={}\nt2.0={}", t1.0, t1.1, t2.0);
    let (a,b,c) = t1;
    println!("t1.0={}\nt1.1={}\nt2.0={}", a, b, c);

    let a1 = [3, 5];
    let a2:[bool;3] = [true, false, true];
    let a3 = [0;5]; // 与 let a3 = [0,0,0,0,0]; 等价
    println!("a1[0]={}\na2[1]={}\na3[4]={}", a1[0], a2[1], a3[4]);

}
